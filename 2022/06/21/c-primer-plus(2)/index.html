<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C语言基础（下） | 李九居のblog</title><meta name="keywords" content="C/C++"><meta name="author" content="李九居"><meta name="copyright" content="李九居"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C primer plus 中一些值得注意的点">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言基础（下）">
<meta property="og:url" content="http://liaozhangsheng.top/2022/06/21/c-primer-plus(2)/index.html">
<meta property="og:site_name" content="李九居のblog">
<meta property="og:description" content="C primer plus 中一些值得注意的点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg">
<meta property="article:published_time" content="2022-06-21T00:31:09.000Z">
<meta property="article:modified_time" content="2022-09-09T02:40:05.106Z">
<meta property="article:author" content="李九居">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="http://liaozhangsheng.top/2022/06/21/c-primer-plus(2)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言基础（下）',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-09 10:40:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/diy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/animate-css/animate.css@3.7.2/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zhheo/JS-Heo@main/rightmenu/rightmenu.css"><link rel="stylesheet" type="text/css" href="https://gcore.jsdelivr.net/gh/zhheo/JS-Heo@main/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://npm.elemecdn.com/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://npm.elemecdn.com/js-heo@1.0.11/poem/poem.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/litten.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoyangtao"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoxiangjiao"></use></svg><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="faa-parent animated-hover site-page child" href="/menu/tags/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaibaocai"></use></svg><span> 标签</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/menu/categories/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguotaozi"></use></svg><span> 分类</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/archives/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaiyumi"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguojuzi"></use></svg><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="faa-parent animated-hover site-page child" href="/list/photos/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_meiweizaocanjidan"></use></svg><span> 相册</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/list/books/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoboluo"></use></svg><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/world/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaiyangcong"></use></svg><span> 小天地</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">李九居のblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoyangtao"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoxiangjiao"></use></svg><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="faa-parent animated-hover site-page child" href="/menu/tags/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaibaocai"></use></svg><span> 标签</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/menu/categories/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguotaozi"></use></svg><span> 分类</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/archives/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaiyumi"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguojuzi"></use></svg><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="faa-parent animated-hover site-page child" href="/list/photos/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_meiweizaocanjidan"></use></svg><span> 相册</span></a></li><li><a class="faa-parent animated-hover site-page child" href="/list/books/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshuiguoboluo"></use></svg><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/world/"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xinxianguoshu_xinxianshucaiyangcong"></use></svg><span> 小天地</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言基础（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-21T00:31:09.000Z" title="发表于 2022-06-21 08:31:09">2022-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-09T02:40:05.106Z" title="更新于 2022-09-09 10:40:05">2022-09-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/C-C/">C/C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言基础（下）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数组和指针">数组和指针</h2>
<h3 id="数组的概述">数组的概述</h3>
<h4 id="声明数组">声明数组</h4>
<p>数组由 <code>数据类型</code> 相同的一系列元素组成。</p>
<p>需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。</p>
<p>普通变量可以使用的类型，数组元素都可以使用。</p>
<p>数组声明示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> candy[<span class="number">365</span>]; <span class="comment">/*内含365个float类型元素的数组*/</span></span><br><span class="line">    <span class="type">char</span> code[<span class="number">12</span>]; <span class="comment">/*内含12个char类型元素的数组*/</span></span><br><span class="line">    <span class="type">int</span> states[<span class="number">50</span>]; <span class="comment">/*内含50个int类型元素的数组*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要有 <code>方括号（[]）</code> 就都是数组，方括号中的数字表明数组中的<code>元素个数</code>。</p>
<p>如果要 <code>访问</code> 数组中的元素，通过使用数组 <code>下标数字（也称为索引）</code>表示数组中的各元素。</p>
<p>数组的元素的编号从 <code>0</code> 开始。</p>
<h4 id="初始化数组">初始化数组</h4>
<p>数组通常被用来储存程序需要的数据。</p>
<p>只储存单个值的变量又叫做 <code> 标量变量（scalar variable）</code>。</p>
<p>用以 <code>逗号</code> 分隔的 <code> 元素值列表（用花括号括起来）</code>来初始化数组，各元素值之间用 <code>逗号</code> 分隔。 在逗号和元素值之间可以使用空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="给数组元素赋值">给数组元素赋值</h4>
<p>声明数组之后，就可以借助数组 <code>下标（或索引）</code>给数组元素赋值。</p>
<p><strong>注意点</strong>：在C语言中，不允许把数组作为一个单位赋值给另一个数组，除了初始化以外也不允许使用花括号列表的形式赋值。</p>
<p>案例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">// 初始化没问题</span></span><br><span class="line">    <span class="type">int</span> yaks[SIZE];</span><br><span class="line"></span><br><span class="line">    yaks = oxen; <span class="comment">// 不允许这么赋值</span></span><br><span class="line">    yaks[SIZE] = oxen[SIZE]; <span class="comment">// 数组的下标越界</span></span><br><span class="line">    yaks[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">// 不起作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用指定初始化器（C99）">使用指定初始化器（C99）</h4>
<p>C99的新特性：<code>指定初始化器（disignated initializer）</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;0,0,0,0,0,0,2&#125;; // 传统的语法</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C99规定，可以初始化列表中使用带方括号的下标指明待初始化的元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;[5] = 2&#125;; // 把arr[5] 初始化为2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于一般的初始化，在初始化一个元素后，末初始化的元素的都会被设置为 0 。</p>
</blockquote>
<p>⚠️注意：<code>在使用数组时，要防止数组下标超出边界。必须确保下标是有效的值</code>。</p>
<h3 id="多维数组">多维数组</h3>
<h4 id="初始化二维数组">初始化二维数组</h4>
<p>初始化二维数组是建立在<code>初始化一维数组</code>的基础上。</p>
<p>初始化一维数组的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 arr[<span class="number">5</span>] = &#123;val01,val02,val03,val04,val05&#125;; <span class="comment">// val01、val02等表示数据类型的值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的<code>数值个数</code>正确，初始化结果就不会出错。</p>
</blockquote>
<blockquote>
<p>如果初始化的数值不够，按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。</p>
</blockquote>
<p>初始化二维数组的两种方法：</p>
<h4 id="其他多维数组">其他多维数组</h4>
<p>声明一个三维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  box[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>]; <span class="comment">// 10个二维数组（每个二维数组都是20行30列）</span></span><br></pre></td></tr></table></figure>
<p>对于多维数组的处理，使用<code>多重循环</code>控制来处理。</p>
<h3 id="数组和指针-2">数组和指针</h3>
<p>指针以<code>符号</code>形式使用地址。</p>
<p><code>数组表示法</code>也是<code>变相使用指针</code>。</p>
<ul>
<li>
<p>指针的值是所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。</p>
</li>
<li>
<p>在指针前面使用运算符可以得到该指针所指向对象的值。</p>
</li>
<li>
<p>指针加1，指针的值递增它所指向<code>类型的大小</code>（以字节为单位）。</p>
</li>
</ul>
<h3 id="函数、数组和指针">函数、数组和指针</h3>
<p>使用数组表示法处理数组的函数，也就是使用指针作为参数。</p>
<p>数组名是数组首元素的地址。</p>
<blockquote>
<p>既可以用<code>指针</code>表示<code>数组名</code>，也可以使用<code>数组名</code>表示<code>指针</code>。</p>
</blockquote>
<h3 id="指针操作">指针操作</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> urn[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr1, *ptr2, *ptr3;</span><br><span class="line"></span><br><span class="line">    ptr1 = urn; <span class="comment">// 指向数组的首个元素，也就是urn数组的首地址</span></span><br><span class="line">    ptr2 = &amp;urn[<span class="number">2</span>];<span class="comment">// 一个地址赋给指针，也就是urn数组的第三个元素(urn[2])的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针的值 ；间接引用指针 ； 指针的地址：\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 解引用：*运算符给出指针指向地址上储存的值。注意：不要解引用未初始化的指针。</span></span><br><span class="line">    <span class="comment">// 取址：指针也有主机的地址和值。&amp;运算符给出指针本身的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p ; *ptr1 = %d ; &amp;ptr1 = %p \n&quot;</span>, ptr1,*ptr1,&amp;ptr1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针的加法：整数都会与指针所指向类型的大小（以字节为单位）相乘，然后结果与初始地址相加。</span></span><br><span class="line">    ptr3 = ptr1 + <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 指针加上一个整数 ：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 + 4 = %p ; *(ptr1 + 4) = %d \n&quot;</span>,ptr1+<span class="number">4</span>,*(ptr1+<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    ptr1++; <span class="comment">// 递增指针：指向数组元素的指针可以让指针移动到数组的下一个元素。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n ptr1++的值是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p ; *ptr1 = %d ; &amp;pt1 = %p \n&quot;</span>,ptr1,*ptr1,&amp;ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2--; <span class="comment">// 递减指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--ptr2的值是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p ; *ptr2 = %d ; &amp;pt2 = %p\n&quot;</span>,ptr2,*ptr2,&amp;ptr2);</span><br><span class="line"></span><br><span class="line">    --ptr1; <span class="comment">// 恢复为初始值</span></span><br><span class="line">    ++ptr2; <span class="comment">// 恢复为初始值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 恢复为初始值的指针为：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p ; ptr2 = %p\n&quot;</span>,ptr1,ptr2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 一个指针减去另一个指针：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p ; ptr1 = %p ; ptr1 - ptr2 = %td \n &quot;</span>,ptr1,ptr2,ptr1 -ptr2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个指针减去一个整数：指针必须是第一个运算对象，整数是第二个运算对象。整数乘以指针指向类型的大小（以字节为单位），然后初始地址减去乘积。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 一个指针减去一个整数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr3 = %p ; ptr3 - 2 = %p \n &quot;</span>,ptr3,ptr3<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="保护数组中的数据">保护数组中的数据</h3>
<p>地址传递往往会导致会出现一些问题，原始数据在传递过程中会被修改。</p>
<p>#define 可以创建类似const功能的符号常量，但由于安全性角度考虑，优先推荐使用 <code>const</code>定义常量。</p>
<p>指针const的指针不能用于改变值。</p>
<p>对函数的形参使用const不仅能保护数据，还能让函数处理const数组。</p>
<h3 id="变长数组（VLA）">变长数组（VLA）</h3>
<p>⚠️注意：变长数组不能改变大小</p>
<blockquote>
<p>变长数组中的“变” 不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。此处的“变” 指的是：在创建数组时，可以使用变量指定数组的维度。</p>
</blockquote>
<p>C99/C11标准规定，可以省略原型中的形参名，可以使用<code>星号</code>来代替省略的<code>维度</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">num2d</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> , <span class="type">int</span> arr[*][*])</span>; <span class="comment">// arr是一个变长数组（VLA），省略了维度形参名。</span></span><br></pre></td></tr></table></figure>
<p><code>变长数组名</code>实际上也是<code>指针</code>。</p>
<p>变长数组允许<code>动态内存分配</code>，说明可以在程序运行时<code>指定数组的大小</code>。</p>
<h2 id="字符串和字符串函数">字符串和字符串函数</h2>
<h3 id="表示字符串和字符串I-O">表示字符串和字符串I/O</h3>
<h4 id="字符串字面值（字符串常量）">字符串字面值（字符串常量）</h4>
<p>用 <code>双引号</code> 括起来的内容称为 <code>字符串字面值（string literal）</code>，也叫做<code>字符串常量（string constant）</code>。</p>
<p>双引号中的字符和编译器自动加入末尾的 <code>\0字符</code>,都作为字符串存储在内存中。</p>
<p>如果要在<code>字符串内部</code>使用 <code>双引号</code>，必须在双引号前面加上<code>反斜杠（\）</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&quot;这是一个字符串常量\&quot;,具体情况看结果&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>字符串常量属于 <code>静态存储类别（static storage class）</code>，说明如果在函数中使用字符串常量，该字符串只会被存储一次。</p>
<h4 id="字符串数组和初始化">字符串数组和初始化</h4>
<p>定义字符串数组时，必须让编译器知道需要的空间。</p>
<p>使用<code>足够的空间</code>来存储字符串。</p>
<p>在指定数组大小时，要确保数组的<code>元素个数</code>至少比字符串<code>长度多1</code>（为了容纳空字符）。</p>
<h4 id="数组和指针的区别">数组和指针的区别</h4>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch01[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ch02 = <span class="string">&quot;Hello cpp!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>区别：</p>
<ul>
<li>数组名ch01是常量，而指针名ch02是变量。</li>
<li>只有指针可进行递增操作。</li>
</ul>
<p>对于指针和数组：</p>
<ul>
<li>都可以使用数组表示法。</li>
<li>都可以进行指针加法操作。</li>
</ul>
<p>如果不修改字符串，不要使用指针指向字符串字面量。</p>
<h3 id="字符串输入">字符串输入</h3>
<p>不要指望计算机在读取字符串时顺便计算它的长度再分配空间。</p>
<blockquote>
<p>最简单的方式：在声明显式指明数组的大小。</p>
</blockquote>
<h4 id="gets-函数"><code>gets()</code> 函数</h4>
<p><code>scanf()</code>和转换说明<code>%s</code>只能读取<code>一个单词</code>。</p>
<p><code>gets()</code>读取一整行的输入，直至遇到换行符，然后丢弃换行符，存储其余字符，并在后面加一个空字符，然成为一个C字符串</p>
<p><code>gets()</code>函数经常和<code>puts()</code>函数<code>配对</code>使用。</p>
<p><code>puts()</code>函数显示字符串，并在<code>末尾添加换行符</code>。</p>
<h4 id="fgets-函数"><code>fgets()</code> 函数</h4>
<p><code>fgets()</code>函数 ------- 专门处理文件输入</p>
<p><code>fgets()</code>函数经常和<code>fputs()</code>函数配对使用，除非该函数不在字符串末尾添加换行符。</p>
<p>gets()和fgets()的区别</p>
<p><code>fgets()</code>遇到<code>换行符</code>会<code>存储在字符串</code>中。gets()函数则会<code>丢弃换行符</code>。</p>
<p>fgets() 函数的语法格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>str 指向一个字符数组的指针，存储要读取的字符串。</li>
<li>n 要读取的最大字符数（包括空字符），通常是是以str传递的数组长度。</li>
<li>stream 指向FILE对象的指针，标识要从中读取字符的流。</li>
</ul>
</blockquote>
<p><code>fgets()</code>中第二个参数是限制读入的字符来防止溢出问题，第三个参数指明要读入的文件，如果从键盘读入，则使用stdin。</p>
<h4 id="scanf-函数-2"><code>scanf()</code> 函数</h4>
<p>使用<code>%</code>转换说明符，<code>scanf</code>函数如果内容过长，会造成<code>数据溢出</code>。</p>
<p>在<code>%s</code>转换说明中使用<code>字段宽度</code>可以<code>防止溢出</code>。</p>
<h3 id="字符串输出">字符串输出</h3>
<p>C语言有3个标准库函数用于打印字符串：<code>puts()</code>、<code>fputs()</code>、<code>printf()</code> 。</p>
<h4 id="puts-函数和fputs-函数"><code>puts()</code>函数和<code>fputs()</code>函数</h4>
<p>fputs()函数是puts()针对文件定制的版本，两者的区别如下：</p>
<ul>
<li><code>fputs()</code>函数的第2个参数指明要写入数据的文件。要显示文件则需要使用stdio.h库中的stdout作为参数。</li>
<li><code>fputs()</code>不会输出的末尾添加换行符。</li>
<li>输入问题：puts()<code>丢弃</code>输入中的换行符，而<code>fputs()保留</code>。</li>
<li>输出问题：puts()<code>添加</code>换行符，而<code>fputs()不添加</code>。</li>
</ul>
<h4 id="printf-函数-2"><code>printf()</code>函数</h4>
<p>细节请参考 「<a href="../Chapter04/README.md">chapter04</a>」</p>
<h3 id="字符串函数">字符串函数</h3>
<p>C语言库中提供多个处理字符串的函数，全部都放在<code>string.h头文件</code>中。</p>
<p>最常用的函数：</p>
<ul>
<li><code>strlen()</code> 统计字符串的长度</li>
<li><code>strcat()</code> 拼接字符串</li>
<li><code>strncat()</code> 拼接两个字符串，然后检查第一个</li>
<li><code>strcmp()</code> 字符串的比较</li>
<li><code>strncmp()</code> 比较字符串中的字符</li>
<li><code>strcpy()</code> 拷贝字符串，相当于字符串赋值运算符</li>
<li><code>strncpy()</code></li>
</ul>
<h4 id="字符串拼接的strcat-函数">字符串拼接的<code>strcat()</code>函数</h4>
<p><code>strcat()</code>函数用于<code>拼接</code>字符串，接受两个字符串作为参数。</p>
<p>把第2个字符串<code>附加</code>在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个则保持不变。</p>
<p><code>strcat()</code>函数的类型是：char *（即，指向char的指针）</p>
<p><code>strcat()</code>函数的缺点：无法检查第1个数组是否可以容纳第2个字符串数组。</p>
<h4 id="strncat-函数"><code>strncat()</code>函数</h4>
<blockquote>
<p>字符串的拼接，并检查第一个数组的大小。</p>
</blockquote>
<p>目的：为了弥补strcat()函数不能检查第一个数组大小的缺陷。防止字符溢出。</p>
<h4 id="比较strcmp-函数">比较<code>strcmp()</code>函数</h4>
<p><code>strcmp()</code>函数比较的是字符串的<code>内容</code>，而不是字符串的地址。也不是字符。</p>
<h4 id="strcpy-函数"><code>strcpy()</code> 函数</h4>
<p>利用<code>strcpy()</code>函数拷贝整个字符串</p>
<p>调用<code>strcpy()</code>把整个字符串从<code>临时数组拷贝</code>到目标数组中。</p>
<p><code>strcpy()</code>函数相当于字符串<code>赋值</code>运算符。</p>
<p><code>strcpy()</code>函数拷贝的是<code>字符串的地址</code>而不是字符串本身。</p>
<p><code>strcpy()</code>函数的两个有用属性</p>
<ul>
<li>返回的类型是<code>char *</code>，返回的事第一个参数的值，也就是一个字符的地址。</li>
<li>第1个参数不必指向数组的开始。该属性一般用于拷贝数组的一部分。</li>
</ul>
<h4 id="strncpy-函数"><code>strncpy()</code> 函数</h4>
<p>注意点：<code>strncpy()</code>函数会<code>检查目标空间</code>是否能够容纳字符串的副本。</p>
<p>调用<code>strncpy()</code>把整个字符串从临时数组拷贝到目标数组中。</p>
<p><code>strncpy()</code>函数相当于字符串赋值运算符。</p>
<p><code>strncpy()</code>函数拷贝的是字符串的地址而不是字符串本身。</p>
<h4 id="sprintf-函数"><code>sprintf()</code> 函数</h4>
<p>把数据写入字符串但不打印在显示器上的<code>sprintf()</code>函数</p>
<p><code>sprintf()</code>函数和printf()函数类似，但是<code>sprintf()</code>函数是把数据写入字符串，但是不打印在显示器上。</p>
<p><code>sprintf()</code>函数的声明是在<code>stdio.h</code>中，而不是在string.h中。</p>
<p><code>sprintf()</code>函数可以把<code>多个元素组合</code>成一个字符串。</p>
<p><code>sprintf()</code>函数的第一个参数是：目标字符串的地址，其它参数和printf()函数相同。</p>
<p>printf()函数的格式：格式字符串和待写入项的列表。</p>
<p>sprintf()函数获取输入，并将其格式化标准形式，然后把格式化后的字符串存储。</p>
<h3 id="字符串排序例子">字符串排序例子</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALT <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [],<span class="type">int</span> num)</span>;<span class="comment">/*字符串排序函数*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[LIM][SIZE]; <span class="comment">/*存储输入的数组*/</span></span><br><span class="line">    <span class="type">char</span> *ptstr[LIM]; <span class="comment">/*内含指针变量的数组*/</span></span><br><span class="line">    <span class="type">int</span> ct = <span class="number">0</span>; <span class="comment">/*输入计数*/</span></span><br><span class="line">    <span class="type">int</span> k; <span class="comment">/*输出计数*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入 %d 行内容，并进行排序!\n&quot;</span>,LIM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请在新的一行按任意键即可停止！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ct&lt;LIM &amp;&amp; s_gets(input[ct],SIZE)!=<span class="literal">NULL</span> &amp;&amp; input[ct][<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptstr[ct] = input[ct]; <span class="comment">/*设置指针指向字符串*/</span></span><br><span class="line">        ct++; <span class="comment">/*统计输入*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    stsrt(ptstr,ct); <span class="comment">/*调用字符串排序函数*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n以下是排序后：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;ct;k++)</span><br><span class="line">        <span class="built_in">puts</span>(ptstr[k]); <span class="comment">/*排序后的指针*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串-指针-排序函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [],<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *temp;</span><br><span class="line">    <span class="type">int</span> top,seek;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(top=<span class="number">0</span>;top&lt;num<span class="number">-1</span>;top++) </span><br><span class="line">        <span class="keyword">for</span>(seek=top+<span class="number">1</span>;seek&lt;num;seek++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings[top],strings[seek])&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp =strings[top];</span><br><span class="line">                strings[top] = strings[seek];</span><br><span class="line">                strings[seek] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * ret_val;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i]!=<span class="string">&#x27;\n&#x27;</span>&amp;&amp;st[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            st[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">while</span> (getchar()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数">命令行参数</h3>
<p>带命令行参数的 <code>main()</code>函数</p>
<p>对于C编译器来说，允许main()<code>没有参数</code>或者是<code>两个参数</code>。当main()函数有两个参数时，</p>
<ul>
<li>
<p>第一个参数：命令行中的字符串的数量。int类型的<code>argc</code>(argument count(表示参数计数))。<br>
系统用空格表示一个字符串的结束和下一个字符串的开始。</p>
</li>
<li>
<p>第二个参数：指向指针的指针叫做<code>argv</code>（表示参数值【argument value】）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*命令行字符串存储，并把每个字符串的地址存储在指针数组中，数组的地址被存储在第二个参数中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv [])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这个命令行有 %d 个参数：&quot;</span>,argc<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(count = <span class="number">1</span>;count&lt;argc;count++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d : %s \n&quot;</span>,count,argv[count]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件输入-输出">文件输入/输出</h2>
<p>文件用于 <code>存储程序、文档、数据、书信、表格、照片、视频</code> 等。</p>
<h3 id="与文件进行通信">与文件进行通信</h3>
<p>文件：通常是在磁盘或固态硬盘上的一段已命名的存储区。</p>
<p>C语言提供两种文件模式：<code>文本模式</code> 和 <code>二进制模式</code>。</p>
<p><strong>所有文件的内容都以<code>二进制形式（0或1）</code>存储</strong>。</p>
<h3 id="标准I-O">标准I/O</h3>
<p>C程序会自动打开3个文件：<strong><code>标准输入（standard input）</code></strong>、<strong><code>标准输出（standard ouput）</code></strong>、<strong><code>标准错误输出（standard error output）</code></strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标准文件</th>
<th style="text-align:center">文件指针</th>
<th style="text-align:center">通常使用的设备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准输入</td>
<td style="text-align:center">stdin</td>
<td style="text-align:center">键盘</td>
</tr>
<tr>
<td style="text-align:center">标准输出</td>
<td style="text-align:center">stdout</td>
<td style="text-align:center">显示器</td>
</tr>
<tr>
<td style="text-align:center">标准错误</td>
<td style="text-align:center">stderr</td>
<td style="text-align:center">显示器</td>
</tr>
</tbody>
</table>
<p>标准I/O的好处：</p>
<ul>
<li>可移植</li>
<li>有专门的函数简化了处理不同I/O的问题</li>
<li>输入和输出都是缓冲（缓冲极大提高数据传输速率）。</li>
</ul>
<p>在打开文件时，程序一定要判断文件是否打开成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fopen==<span class="literal">NULL</span>)&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一旦打开失败，直接会终止后续操作。</p>
</blockquote>
<p><code>exit() 函数</code> 关闭所有打开的文件并结束程序。</p>
<p>在stdlib.h头文件中：</p>
<blockquote>
<p>标准要求 <code>0 </code>或 宏 <code>EXIT_SUCCESS</code>：表明成功结束程序。</p>
<p>宏 <code>EXIT_FAILURE</code>：表明结束程序失败。</p>
</blockquote>
<h4 id="fopen-和-fclose-函数"><code>fopen()</code> 和 <code>fclose()</code> 函数</h4>
<p>都声明在 <code>stdlib.h</code> 头文件中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">函数原型</th>
<th style="text-align:left">语法格式</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>fopen()</code></td>
<td style="text-align:left"><code>FILE *fopen(const char *filename,const char * mode);</code></td>
<td style="text-align:left"><code>FILE *fp = fopen(&quot;filename&quot;,mode)</code></td>
<td style="text-align:left">打开文件</td>
<td style="text-align:left">返回一个文件指针：FILE *fp 指向一个记录文件信息的数据结构<br>例：<code>fp = fopen(&quot;hello_c.txt&quot;,&quot;r&quot;);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>fclose()</code></td>
<td style="text-align:left"><code>int fclose(FILE * stream);</code></td>
<td style="text-align:left"><code>fclose(fp)</code></td>
<td style="text-align:left">关闭文件</td>
<td style="text-align:left">关闭成功返回0，失败返回EOF(-1)，存储空间不足或者被移除都会出现I/O错误，都会导致失败。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>文件指针的类型是指向FILE的指针，FILE是一个定义在 <code>stdlib.h</code> 中的<code>派生类型</code>。</p>
</blockquote>
<p>mode的内容参考：<br>
<img src="img/fopen%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt=""></p>
<h4 id="getc-和-putc-函数"><code>getc()</code> 和 <code>putc()</code> 函数</h4>
<p>与 <code>getchar()</code> 和 <code>putchar()</code> 函数类似。</p>
<p>区别：</p>
<blockquote>
<p>需要告知 <code>getc()</code> 和 <code>putc()</code> 函数 使用哪一个文件。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">函数原型</th>
<th style="text-align:left">语法格式</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>gets()</code></td>
<td style="text-align:left"><code>int getc(FILE *stream)</code></td>
<td style="text-align:left"><code>ch = getc(fp)</code></td>
<td style="text-align:left">从fp指定文件中获取一个字符，读到文件结尾返回EOF</td>
<td style="text-align:left"><code>getc(stdin) == getchar(ch);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>putc()</code></td>
<td style="text-align:left"><code>int putc(int char,FILE *stream)</code></td>
<td style="text-align:left"><code>putc(ch,fp)</code></td>
<td style="text-align:left">把ch放入fp指向文件</td>
<td style="text-align:left"><code>puts(ch,stdout) == putchar(ch);</code></td>
</tr>
</tbody>
</table>
<h4 id="一个简单的文件压缩程序">一个简单的文件压缩程序</h4>
<p>例子：把一个文件中选定的数据拷贝到另一个文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reducto.c 把文件压缩成原来的1/3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//提供exi()原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> <span class="comment">//提供strcpy()、strcat()原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 40</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE * in, *out; <span class="comment">//声明两个指向FILE的指针</span></span><br><span class="line">	<span class="type">int</span> ch; </span><br><span class="line">	<span class="type">char</span> name[LEN]; <span class="comment">//存储输出文件名</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)<span class="comment">//检查命令行参数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">//表明程序失败退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置输入，设置mode为可读</span></span><br><span class="line">	<span class="keyword">if</span> ((in = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;I couldn&#x27;t open the file \&quot;%s\&quot;\n &quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置输出</span></span><br><span class="line">	<span class="built_in">strncpy</span>(name, argv[<span class="number">1</span>], LEN - <span class="number">5</span>); <span class="comment">// 拷贝文件名</span></span><br><span class="line">	name[LEN - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">strcat</span>(name, <span class="string">&quot;.red&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((out = <span class="built_in">fopen</span>(name, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) <span class="comment">//设置可写方式打开file</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t create output file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝数据</span></span><br><span class="line">	<span class="keyword">while</span> ( (ch=<span class="built_in">getc</span>(in))!=EOF) <span class="comment">//通过使用EOF来告知程序已经读取到文件结尾，从而结束程序。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">putc</span>(ch, out);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fclose</span>(in) != <span class="number">0</span> || <span class="built_in">fclose</span>(out) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in closing files.\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>fprintf()</code>和 <code>printf()</code> 类似，⚠️注意点：<code>fptrintf()</code> 第一个参数必须是一个<code>文件指针</code>。</p>
</blockquote>
<h4 id="标准I-O的原理">标准I/O的原理</h4>
<p>步骤：</p>
<ul>
<li>
<p>调用<code>fopen()</code>打开文件。</p>
<ul>
<li><code>fopen()</code>不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。</li>
<li>fopen()返回一个指向该结构的指针，以便其他函数知道该如何找到该结构。</li>
<li>结构中通常包含一个指定流中当前未知的文件位置指示器。还包括错误和文件结尾的指示器、一个指向缓冲区开始处的指针，一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。</li>
</ul>
</li>
<li>
<p>调用一个定义在 <code>stdio.h</code> 中的输入函数，如<code>fscanf()、getc()或fgets()</code>。</p>
<ul>
<li>调用函数时，文件中的数据块会被拷贝到缓冲区中，最初调用函数，除了填充缓冲区外，还要设置指针变量所指向的结构中的值。</li>
<li>在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据，在读取数据时，文件位置指示器被设置为指向刚读取字符的下一个字符。</li>
<li>当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。</li>
<li>输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。</li>
</ul>
</li>
</ul>
<h3 id="文件I-O：fprintf-、fscanf-、fgets-、fputs">文件I/O：<code>fprintf()、fscanf()、fgets()、fputs()</code></h3>
<h4 id="fprintf-和-fscanf-函数"><code>fprintf()</code> 和 <code>fscanf()</code> 函数</h4>
<p><code>fprintf()</code> 和 <code>fscanf()</code>函数的工作方式与 <code>printf()</code> 和 <code>fscanf()</code>函数的类似。</p>
<p>👉小区别：</p>
<blockquote>
<p><code>fprintf()</code> 和 <code>fscanf()</code> 函数的第一个参数<code>必须指定待处理的文件</code>。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*addaword.c --fprintf() fscanf() rewind()*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 41</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="type">char</span> words[MAX];</span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(<span class="string">&quot;wordy&quot;</span>, <span class="string">&quot;a+&quot;</span>)) == <span class="literal">NULL</span>) <span class="comment">//更新（读写）模式打开文件，只允许在文件末尾添加内容</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Can&#x27;t open \&quot;wordy\&quot; file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter words to add to the file; press the #&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;key at the beginning of a line to terminate.&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="built_in">fscanf</span>(stdin, <span class="string">&quot;%40s&quot;</span>, words) == <span class="number">1</span>) &amp;&amp; (words[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">		<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\n&quot;</span>, words);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;File contents:&quot;</span>);</span><br><span class="line">    <span class="comment">/** 关于 rewind() 函数的介绍说明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * rewind()函数 在头文件 stdio.h 中</span></span><br><span class="line"><span class="comment">     * 用于将文件指针重新指向文件的开头，同时清除和文件流相关的错误和EOF标记。</span></span><br><span class="line"><span class="comment">     * 相当于调用 fseek()函数</span></span><br><span class="line"><span class="comment">     * 函数原型：void rewind(FILE *stream);</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">rewind</span>(fp);<span class="comment">//回到文件开始处。</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fclose</span>(fp) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error closing file\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机访问">随机访问</h3>
<h4 id="fseek-和-ftell-函数"><code>fseek()</code> 和 <code>ftell()</code> 函数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">函数原型</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fseek()</code></td>
<td style="text-align:left"><code>int fseek(FILE *stream, long int offset, int whence);</code></td>
<td style="text-align:left">重定位流上的文件指针</td>
<td style="text-align:left">第一个参数stream为<code>文件指针</code><br>第二个参数offset为<code>偏移量</code>，正数表示正向偏移，负数表示负向偏移<br>第三个参数是<code>模式</code>，确定文件起始点,几种明示常量为：<code>SEEK_SET（文件开头）、 SEEK_CUR（当前位置） 或 SEEK_END（文件末尾）</code></td>
<td style="text-align:left">如果成功，则该函数返回零，否则返回非零值。</td>
</tr>
<tr>
<td style="text-align:left"><code>ftell</code></td>
<td style="text-align:left"><code>long ftell(FILE *stream);</code></td>
<td style="text-align:left">得到文件位置指针当前位置相对于文件首的偏移字节数。</td>
<td style="text-align:left"><code>FILE *stream</code>返回指针的文件流</td>
<td style="text-align:left">成功----返回当前文件指针的位置<br>出错----返回-1L，是长整数的-1值。</td>
</tr>
</tbody>
</table>
<p><code>fseek</code>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//定位至文件开始处</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">10L</span>,SEEK_SET); <span class="comment">//定位至文件中的第10个字节</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//从文件当前位置前移2个字节</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">// 定位至文件结尾</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">-10L</span>,SEEK_END); <span class="comment">// 从文件结尾处回退10个</span></span><br></pre></td></tr></table></figure>
<p><code>ftell</code>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *stream;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	stream = <span class="built_in">fopen</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>); <span class="comment">// 只读方式打开</span></span><br><span class="line">	<span class="keyword">if</span>(stream == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;打开文件错误&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fseek</span>(stream,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	len = <span class="built_in">ftell</span>(stream); <span class="comment">//返回类型为long，把file.txt文件开始处到文件结尾的字节数赋给len</span></span><br><span class="line">	<span class="built_in">fclose</span>(stream);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;file.txt的总大小为 = %d 字节\n&quot;</span>,len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设文件file.txt中的内容为</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.github.com/solerho</span><br></pre></td></tr></table></figure>
<p>使用gcc运行程序后结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos8 examples]# gcc ftell.c </span><br><span class="line">[root@centos8 examples]# ls</span><br><span class="line">a.out  file.txt  ftell.c</span><br><span class="line">[root@centos8 examples]# ./a.out </span><br><span class="line">file.txt的总大小为 = 23 字节</span><br></pre></td></tr></table></figure>
<h4 id="fgetpos-和-fsetpos-函数"><code>fgetpos()</code> 和 <code>fsetpos()</code> 函数</h4>
<ul>
<li>fgetpos() 函数</li>
</ul>
<p>语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">( FILE *stream, <span class="type">fpos_t</span> *position )</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：</p>
<p><strong>stream</strong> : 当前文件流的指针</p>
<p><strong>fpos_t</strong> : 用来表示文件读写指针位置的类型，用来指明正在操作的文件中读或写的位置，文件头处为0。fpos_t在不同的平台下有不同的类型。</p>
<p><strong>position</strong> ： 指向 fpos_t 对象的指针</p>
<p><strong>功能</strong>：处理较大文件（字节数超过long范围），解决 <code>fseek()</code> 和 <code>ftell()</code>函数存在的问题。</p>
<p><strong>返回值</strong>：执行成功时返回0，否则返回非0值。<br>
ANSI C定义了如何使用 <code>fpos_t</code> 类型，<code>fgetpos()</code> 函数的原型如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE * restrict stream,<span class="type">fpos_t</span> * restrict pos)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fsetpos()</code> 函数</li>
</ul>
<p>语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream,<span class="type">const</span> <span class="type">fpost_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用函数时，使用pos指向位置上的 <code>fpos_t</code> 类型值来设置文件指针指向该值指定的位置。</p>
<p>函数成功返回0，失败则返回非0。</p>
</blockquote>
<h3 id="二进制I-O：fread-和-fwrite">二进制I/O：<code>fread()</code> 和 <code>fwrite()</code></h3>
<p>如果以程序所用的表示法把数据储存在文件中。则称以<code>二进制形式存储数据</code>。</p>
<p>不存在从<code>数值形式</code>到<code>字符串</code>的转换过程。对于标准I/O，<code>fread()</code> 和 <code>fwrite()</code> 函数用于以二进制形式处理数据。</p>
<p>所有的数据都是以 二进制形式存储。</p>
<p>ANSI C 和许多OS都识别两种文件格式：<code>二进制</code> 和 <code>文本</code>。</p>
<h3 id="其他I-O函数">其他I/O函数</h3>
<blockquote>
<p>一般都是成功返回0，不成功返回非零值：EOF（-1）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">函数原型</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ungetc()</code></td>
<td style="text-align:left"><code>int ungetc(int c, FILE* fp)</code></td>
<td style="text-align:left">把c指定的字符放回输入流中，如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>fflush()</code></td>
<td style="text-align:left"><code>int fflush(FILE *stream)</code></td>
<td style="text-align:left">调用函数引起输出缓冲区中所有的未写入数据被发送到stream指定的输出文件，该过程叫作 <strong><code>刷新缓冲区</code></strong>。<br>如果指针stream是空指针，所有输出缓冲区都被刷新。</td>
</tr>
<tr>
<td style="text-align:left"><code>setvbuf()</code></td>
<td style="text-align:left"><code>int setvbuf(FILE* fp, char * buf, int mode, size_t size);</code></td>
<td style="text-align:left">创建一个提供I/O函数替换使用的缓冲区。</td>
</tr>
</tbody>
</table>
<h4 id="size-t-fwrite-函数"><code>size_t fwrite()</code> 函数</h4>
<p><code>fwrite()</code> 函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * restrict ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> nmemb,FILE * restrict stream)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>指针ptr</code> ：待写入数据块的地址。</p>
<p><code>size</code>：待写入数据块的大小（以字节为单位）。</p>
<p><code>nmemb</code> ：待写入数据块的数量。</p>
<p><code>stream</code> ：指定待写入的文件。<br>
<code>fwrite()</code> 函数返回成功写入项的数量。</p>
</blockquote>
<h4 id="size-t-fread-函数"><code>size_t fread()</code> 函数</h4>
<p><code>fread()</code> 函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> * restrict ptr,,<span class="type">size_t</span> size,<span class="type">size_t</span> nmemb,FILE * restrict stream)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 <code>fread()</code> 函数中，<code>ptr</code> 是待读取文件数据在内存中的地址。<code>stream</code> 指定待读取的文件。</p>
<p>fread() 函数返回成功读取项的数量。</p>
</blockquote>
<h4 id="int-feof-FILE-fp-和-int-ferror-FILE-fp-函数"><code>int feof(FILE *fp)</code> 和 <code>int ferror(FILE *fp)</code> 函数</h4>
<p>如果标准输入函数EOF，则通常表明函数已到达文件结尾。</p>
<blockquote>
<p><code>feof()</code> 函数返回一个非零值，否则返回0。</p>
<p><code>ferror()</code> 函数返回一个非零值，否则返回0。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* append.c -- 把文件附加到另一个文件末尾 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEN 81</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(FILE *source, FILE *dest)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fa, *fs;     <span class="comment">// fa 指向目标文件，fs 指向源文件</span></span><br><span class="line">   <span class="type">int</span> files = <span class="number">0</span>;     <span class="comment">// 附加的文件数量</span></span><br><span class="line">   <span class="type">char</span> file_app[SLEN];  <span class="comment">// 目标文件名</span></span><br><span class="line">   <span class="type">char</span> file_src[SLEN];  <span class="comment">// 源文件名</span></span><br><span class="line">   <span class="type">int</span> ch;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Enter name of destination file:&quot;</span>);</span><br><span class="line">   <span class="built_in">s_gets</span>(file_app, SLEN);</span><br><span class="line">   <span class="keyword">if</span> ((fa = <span class="built_in">fopen</span>(file_app, <span class="string">&quot;a+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file_app);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">setvbuf</span>(fa, <span class="literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t create output buffer\n&quot;</span>, stderr);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Enter name of first source file (empty line to quit):&quot;</span>);</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">s_gets</span>(file_src, SLEN) &amp;&amp; file_src[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file_src, file_app) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t append file to itself\n&quot;</span>, stderr);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((fs = <span class="built_in">fopen</span>(file_src, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file_src);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setvbuf</span>(fs, <span class="literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t create input buffer\n&quot;</span>, stderr);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">append</span>(fs, fa);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ferror</span>(fs) != <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in reading file %s.\n&quot;</span>,</span><br><span class="line">               file_src);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ferror</span>(fa) != <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in writing file %s.\n&quot;</span>,</span><br><span class="line">               file_app);</span><br><span class="line">        <span class="built_in">fclose</span>(fs);</span><br><span class="line">        files++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File %s appended.\n&quot;</span>, file_src);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Next file (empty line to quit):&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Done appending. %d files appended.\n&quot;</span>, files);</span><br><span class="line">   <span class="built_in">rewind</span>(fa);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s contents:\n&quot;</span>, file_app);</span><br><span class="line">   <span class="keyword">while</span> ((ch = <span class="built_in">getc</span>(fa)) != EOF)</span><br><span class="line">     <span class="built_in">putchar</span>(ch);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Done displaying.&quot;</span>);</span><br><span class="line">   <span class="built_in">fclose</span>(fa);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(FILE *source, FILE *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">size_t</span> bytes;</span><br><span class="line">   <span class="type">static</span> <span class="type">char</span> temp[BUFSIZE];  <span class="comment">// 只分配一次</span></span><br><span class="line">   <span class="keyword">while</span> ((bytes = <span class="built_in">fread</span>(temp, <span class="built_in">sizeof</span>(<span class="type">char</span>), BUFSIZE, source)) &gt; <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">fwrite</span>(temp, <span class="built_in">sizeof</span>(<span class="type">char</span>), bytes, dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> * ret_val;</span><br><span class="line">   <span class="type">char</span> * find;</span><br><span class="line">   ret_val = <span class="built_in">fgets</span>(st, n, stdin);</span><br><span class="line">   <span class="keyword">if</span> (ret_val)</span><br><span class="line">   &#123;</span><br><span class="line">     find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);   <span class="comment">// 查找换行符</span></span><br><span class="line">     <span class="keyword">if</span> (find)          <span class="comment">// 如果地址不是NULL，</span></span><br><span class="line">        *find = <span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 在此处放置一个空字符</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用二进制I-O进行随机访问">用二进制I/O进行随机访问</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* randbin.c -- 用二进制I/O进行随机访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARSIZE 1000</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span> numbers[ARSIZE];</span><br><span class="line">   <span class="type">double</span> value;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> * file = <span class="string">&quot;numbers.dat&quot;</span>;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> pos;</span><br><span class="line">   FILE *iofile;</span><br><span class="line">   <span class="comment">// 创建一组 double类型的值</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARSIZE; i++)</span><br><span class="line">     numbers[i] = <span class="number">100.0</span> * i + <span class="number">1.0</span> / (i + <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 尝试打开文件</span></span><br><span class="line">   <span class="keyword">if</span> ((iofile = <span class="built_in">fopen</span>(file, <span class="string">&quot;wb&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not open %s for output.\n&quot;</span>, file);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 以二进制格式把数组写入文件</span></span><br><span class="line">   <span class="built_in">fwrite</span>(numbers, <span class="built_in">sizeof</span>(<span class="type">double</span>), ARSIZE, iofile);</span><br><span class="line">   <span class="built_in">fclose</span>(iofile);</span><br><span class="line">   <span class="keyword">if</span> ((iofile = <span class="built_in">fopen</span>(file, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">        <span class="string">&quot;Could not open %s for random access.\n&quot;</span>, file);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 从文件中读取选定的内容</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Enter an index in the range 0-%d.\n&quot;</span>, ARSIZE - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i) == <span class="number">1</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; i &lt; ARSIZE)</span><br><span class="line">   &#123;</span><br><span class="line">     pos = (<span class="type">long</span>) i * <span class="built_in">sizeof</span>(<span class="type">double</span>);  <span class="comment">// 计算偏移量</span></span><br><span class="line">     <span class="built_in">fseek</span>(iofile, pos, SEEK_SET);    <span class="comment">// 定位到此处</span></span><br><span class="line">     <span class="built_in">fread</span>(&amp;value, <span class="built_in">sizeof</span>(<span class="type">double</span>), <span class="number">1</span>, iofile); <span class="comment">//读取该位置上的数据值</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The value there is %f.\n&quot;</span>, value);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Next index (out of range to quit):\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 完成</span></span><br><span class="line">   <span class="built_in">fclose</span>(iofile);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构和其他数据形式">结构和其他数据形式</h2>
<p>C语言中，提供结构变量 可以提高表示数据的能力，创造新的形式。</p>
<h3 id="示例问题：创建图书目录">示例问题：创建图书目录</h3>
<p>打印图书目录，包括：书名、作者、价格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">s_gets</span><span class="params">(<span class="type">char</span> * st,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTITL 41; <span class="comment">// 书名最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX AUTL 31; <span class="comment">// 作者名字的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">book</span>&#123;</span><br><span class="line">    <span class="type">char</span> title[MAXTITL];</span><br><span class="line">    <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;;<span class="comment">//结构模版结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">book</span> library; <span class="comment">// 把library声明为一个book类型的变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the book title.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(library.title, MAXTITL);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now enter the author.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(library.author, MAXAUTL);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now enter the value.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s by %s: $%.2f\n&quot;</span>, library.title, library.author, library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s: \&quot;%s\&quot;($%.2f)\n&quot;</span>, library.author, library.title, library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">s_gets</span><span class="params">(<span class="type">char</span> * st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> * ret_val;</span><br><span class="line">	<span class="type">char</span> * find;</span><br><span class="line">	ret_val = <span class="built_in">fgets</span>(st, n, stdin);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)  </span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);<span class="comment">//查找换行符</span></span><br><span class="line">		<span class="keyword">if</span> (find)              <span class="comment">//如果地址不是NULL</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//将换行符换成&#x27;\0&#x27;</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//处理输入行剩余的字符</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构的3个技巧</p>
<blockquote>
<ul>
<li>为结构建立一个格式或样式。</li>
<li>声明一个适合该样式的变量。</li>
<li>访问结构变量的各个部分。</li>
</ul>
</blockquote>
<h3 id="建立结构声明">建立结构声明</h3>
<ul>
<li>
<p><code>结构声明（structure declaration）</code>描述了一个结构的组织布局。</p>
</li>
<li>
<p>在结构声明，用<code>一对花括号</code>括起来的是<code>结构成员列表</code>。每个成员都可以是任意一种C的数据类型。</p>
</li>
<li>
<p>右花括号后面的分号是声明必需，表示结构布局定义结束。</p>
</li>
<li>
<p>结构声明可以放在所有函数的外部，也可以放在一个函数定义的内部，但是如果把声明放在函数内部，它的标记只局限于该函数内部使用。</p>
</li>
<li>
<p>结构的标记名是可选的，但是在一处定义结构布局，在另一处定义实际的结构变量，必须使用标记。</p>
</li>
</ul>
<h3 id="定义结构变量">定义结构变量</h3>
<p>结构的含义：</p>
<blockquote>
<ul>
<li>
<p>结构布局告诉编译器如何表示数据，但不让编译器为数据分配空间。</p>
</li>
<li>
<p>创建另一个结构变量。</p>
</li>
</ul>
</blockquote>
<h4 id="初始化结构">初始化结构</h4>
<p>让每个成员的初始化项独占一行。目的：提高代码的可读性，对编译器而言，只需要用逗号分隔各成员的初始化项。</p>
<ul>
<li>
<p>初始化一个结构变量（ANSI之前，不能自动变量初始化结构，ANSI之后可以用任意存储类别）与初始化数组的语法类似。</p>
</li>
<li>
<p>使用在一对花括号中括起来的初始化列表进行初始化，各初始化项用逗号分隔。</p>
</li>
</ul>
<p><strong>⚠️注意：初始化结构和类别存储期</strong></p>
<ul>
<li>
<p>如果初始化一个静态存储期的结构，初始化列表中的值必须是常量表达式。</p>
</li>
<li>
<p>如果是自动存储期，初始化列表中的值可以不是常量。</p>
</li>
</ul>
<h4 id="访问结构成员">访问结构成员</h4>
<ul>
<li>使用结构成员运算符 ————&gt; <code>点(.)</code> 访问结构中的成员。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*访问library中的title部分*/</span></span><br><span class="line">library.title = <span class="string">&quot;C Primer Plus&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>点(.)</code> 比 <code>地址符(&amp;)</code> 优先级高。</li>
</ul>
<h4 id="结构的初始化器">结构的初始化器</h4>
<ul>
<li>C99和C11为结构提供了指定<code>初始化器（也叫标记化结构初始化语法）</code>，结构的指定初始化器使用<code>点运算符</code>和<code>成员名（而不是方括号和下标）标识</code>特定的元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">book</span> gift = &#123;</span><br><span class="line">	.price = <span class="number">69.00</span>,</span><br><span class="line">	.author = <span class="string">&quot;Stephen Prata&quot;</span>,</span><br><span class="line">	.title = <span class="string">&quot;c primer plus&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在指定初始化器后面的<code>普通初始化器</code>，为指定成员后面的成员提供初始值。</p>
</li>
<li>
<p>指定成员的最后一次赋值才是它实际获得的值。</p>
</li>
</ul>
<h3 id="结构数组">结构数组</h3>
<h4 id="声明结构数组">声明结构数组</h4>
<p>声明结构数组和声明其他类型的数组类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把library声明为一个内含MAXBKS个元素的数组*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">book</span> library[MAXBKS];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组名library不是结构名，是数组名。数组中的每个元素都是struct book类型的结构变量。</p>
</blockquote>
<h4 id="标识结构数组的成员">标识结构数组的成员</h4>
<p>为了表示结构数组中的成员，采用访问单独结构的规则：在结构名后面加一个点运算符，再在点运算符后面加上成员名。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">0</span>].price  <span class="comment">/*第1个数组元素与price相关联*/</span></span><br><span class="line">library[<span class="number">4</span>].title  <span class="comment">/*第5个数组元素与title相关联*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️注意：<em><strong>数组下标紧跟在数组名（如library后面），不是成员名后面。</strong></em></p>
</blockquote>
<h4 id="嵌套结构">嵌套结构</h4>
<p>嵌套结构：在一个结构中包含另一个结构。<br>
如果访问嵌套结构的成员，需要使用两次点运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 20</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * msgs[<span class="number">5</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot; Thank you for the wonderful evening, &quot;</span>,</span><br><span class="line">	<span class="string">&quot;You certainly prove that a &quot;</span>,</span><br><span class="line">	<span class="string">&quot;is a special kind of guy. We must get together&quot;</span>,</span><br><span class="line">	<span class="string">&quot;over a delicious &quot;</span>,</span><br><span class="line">	<span class="string">&quot; and have a few laughs&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">names</span> &#123;</span><br><span class="line">	<span class="type">char</span> first[LEN];</span><br><span class="line">	<span class="type">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">guy</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">names</span> handle;  <span class="comment">//嵌套结构，结构里包含另一个结构</span></span><br><span class="line">	<span class="type">char</span> favfood[LEN];</span><br><span class="line">	<span class="type">char</span> job[LEN];</span><br><span class="line">	<span class="type">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">guy</span> fellow = &#123;</span><br><span class="line">		&#123;<span class="string">&quot;Ewen&quot;</span>, <span class="string">&quot;Villard&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;grilled salmon&quot;</span>,</span><br><span class="line">		<span class="string">&quot;personality coach&quot;</span>,</span><br><span class="line">		<span class="number">68112.00</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Dear %s,\n\n&quot;</span>, fellow.handle.first); <span class="comment">//使用嵌套结构，先使用.得到name，再.得到first</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s%s.\n&quot;</span>, msgs[<span class="number">0</span>], fellow.handle.first); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, msgs[<span class="number">1</span>], fellow.job);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msgs[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s%s%s&quot;</span>, msgs[<span class="number">3</span>], fellow.favfood, msgs[<span class="number">4</span>]);</span><br><span class="line">	<span class="keyword">if</span> (fellow.income &gt; <span class="number">150000.0</span>)</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;!!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fellow.income &gt; <span class="number">75000.0</span>)</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%40s%s\n&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;See you soon,&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%40s%s\n&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;Shalala&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指向结构的指针">指向结构的指针</h3>
<p>使用指向结构的指针的理由：</p>
<ul>
<li>指向结构的指针通常是结构本身更容易操控（指向数组的指针比数组本身更容易操控）。</li>
<li>早期C实现，结构不能作为参数传递给函数，可以传递指向结构的指针。</li>
<li>能传递一个结构，传递指针通常更有效率。</li>
<li>一些用于表示数据的结构中包含指向其它结构的指针。</li>
</ul>
<h4 id="声明和初始化结构指针">声明和初始化结构指针</h4>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">guy</span> *him;</span><br></pre></td></tr></table></figure>
<p>与数组不同的是，<s>结构名并不是结构的地址</s>，因此在结构名前加上<code>&amp;运算符</code>。</p>
<h4 id="用指针访问成员">用指针访问成员</h4>
<p>两种方式：</p>
<ul>
<li>
<p>使用 <code>-&gt;</code> 运算符</p>
<ul>
<li>如果 him==&amp;barney ,那么 him-&gt;income 即是 barney.income</li>
<li>如果 him==&amp;fellow[0] , 那么 him-&gt;income 即是 fellow [0].income</li>
</ul>
</li>
<li>
<p>用<code>运算符</code>（必须使用<code>圆括号</code>，因为<code>(.)运算符</code>比<code>(*)</code>运算符的优先级高）。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barney.income == (*him) . income == him-&gt;income <span class="comment">//假设him== &amp;barney</span></span><br><span class="line">fellow [<span class="number">0</span>].income == (*him) .income</span><br></pre></td></tr></table></figure>
<p>有些系统，<strong>一个结构的大小可能大于它各成员大小之和</strong>。</p>
<h3 id="向函数传递结构的信息">向函数传递结构的信息</h3>
<p>函数的参数把值（都是数字—&gt; int类型，float类型、ASCII字符码、地址）传递给函数。</p>
<h4 id="传递结构成员">传递结构成员</h4>
<p>只要结构成员是一个具有单个值的数据类型（即int及其相关类型、char、float、double或指针），可作为参数传递给接受该特定类型的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把结构成员作为参数传递*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">funds</span> &#123;</span><br><span class="line">	<span class="type">char</span>   bank[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> bankfund;</span><br><span class="line">	<span class="type">char</span>   save[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">funds</span> stan = &#123;</span><br><span class="line">		<span class="string">&quot;Garlic-Melon Bank&quot;</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">&quot;Lucky&#x27;s Savings and Loan&quot;</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of $%.2f.\n&quot;</span>,</span><br><span class="line">		<span class="built_in">sum</span>(stan.bankfund, stan.savefund));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* adds two double numbers */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递结构的地址">传递结构的地址</h4>
<p>必须使用<code>&amp;运算符</code>来获取<code>结构的地址</code>，结构名只是其地址的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNDLEN 50</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">funds</span> &#123;</span><br><span class="line">	<span class="type">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> bankfund;</span><br><span class="line">	<span class="type">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> funds *)</span></span>; <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">funds</span> stan = &#123;</span><br><span class="line">		<span class="string">&quot;Garlic--Melon Bank&quot;</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">&quot;Lucky&#x27;s Savings and Loan&quot;</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of $%.2f.\n&quot;</span>, <span class="built_in">sum</span>(&amp;stan)); <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> funds * money)</span> <span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (money-&gt;bankfund + money-&gt;savefund);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递结构">传递结构</h4>
<p>把结构作为参数的编译器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNDLEN 50</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">funds</span> &#123;</span><br><span class="line">	<span class="type">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> bankfund;</span><br><span class="line">	<span class="type">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="type">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">( <span class="keyword">struct</span> funds moolah)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">funds</span> stan = &#123;</span><br><span class="line">		<span class="string">&quot;Garlic--Melon Bank&quot;</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">&quot;Lucky&#x27;s Savings and Loan&quot;</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of $%.2f.\n&quot;</span>, <span class="built_in">sum</span>(stan));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*编译器会为funds结构创建一个名为moolah的自动结构变量副本，然后对副本进行操作（不会改变实际参数stan）*/</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">( <span class="keyword">struct</span> funds moolah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*类似给结构起个别名，然后通过别名来对其进行访问*/</span></span><br><span class="line">	<span class="keyword">return</span>( moolah.bankfund + moolah.savefund);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他结构特性">其他结构特性</h4>
<ul>
<li>
<p>新标准的C允许把一个结构赋值给另一个结构，但数组不行。即使成员是数组，也能完成赋值。</p>
</li>
<li>
<p>现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。</p>
<blockquote>
<p>把结构作为函数参数可以把结构的信息传送给函数，把结构作为返回值的函数能把结构的信息从被调函数传回给主调函数。</p>
</blockquote>
</li>
</ul>
<p>👉<strong>小Tips</strong>：结构指针允许双向通信。</p>
<p><strong>方法1:使用指针方式 ————&gt; 传递地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLEN 30</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">namect</span>&#123;</span><br><span class="line">	<span class="type">char</span> fname[NLEN];</span><br><span class="line">	<span class="type">char</span> lname[NLEN];</span><br><span class="line">	<span class="type">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getinfo</span><span class="params">(<span class="keyword">struct</span> namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeinfo</span><span class="params">(<span class="keyword">struct</span> namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">namect</span> person;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getinfo</span>(&amp;persion);</span><br><span class="line">	<span class="built_in">makeinfo</span>(&amp;person);</span><br><span class="line">	<span class="built_in">showinfo</span>(&amp;person);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getinfo</span><span class="params">(<span class="keyword">struct</span> namect *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;please enter your first name.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(pst-&gt;fname,NLEN);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;please enter your last name.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(pst-&gt;lname,NLEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeinfo</span><span class="params">(<span class="keyword">struct</span> namect *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pst-&gt;letters = <span class="built_in">strlen</span>(pst-&gt;fname) + <span class="built_in">strlen</span>(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> namect *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %s , your name contains %d letters.\n&quot;</span>,</span><br><span class="line">			pst-&gt;fname,pst-&gt;lname,pst-&gt;letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *ret_val;</span><br><span class="line">	<span class="type">char</span> *find;</span><br><span class="line"></span><br><span class="line">	ret_val = <span class="built_in">fgets</span>(st,n,stdin);</span><br><span class="line">	<span class="keyword">if</span>(ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//查找换行符</span></span><br><span class="line">		<span class="keyword">if</span>(find) <span class="comment">// 如果地址不是NULL</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">getchar</span>() !=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			 <span class="keyword">continue</span>; <span class="comment">// 处理输入行的剩余字符</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：使用结构 ————&gt; 传递结构</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLEN 30</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">namect</span>&#123;</span><br><span class="line">	<span class="type">char</span> fname[NLEN];</span><br><span class="line">	<span class="type">char</span> lname[NLEN];</span><br><span class="line">	<span class="type">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">namect</span> <span class="built_in">getinfo</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">namect</span> <span class="built_in">makeinfo</span>(<span class="keyword">struct</span> namect);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">namect</span> person;</span><br><span class="line"></span><br><span class="line">	person = <span class="built_in">getinfo</span>();</span><br><span class="line">	person = <span class="built_in">makeinfo</span>(person);</span><br><span class="line">	<span class="built_in">showinfo</span>(person);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getinfo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">namect</span> temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;please enter your first name.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(temp.fname,NLEN);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;please enter your last name.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">s_gets</span>(temp.lname,NLEN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeinfo</span><span class="params">(<span class="keyword">struct</span> namect *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pst-&gt;letters = <span class="built_in">strlen</span>(pst-&gt;fname) + <span class="built_in">strlen</span>(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showinfo</span><span class="params">(<span class="keyword">struct</span> namect info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %s , your name contains %d letters.\n&quot;</span>,</span><br><span class="line">			info.fname,info.lname,info.letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">s_gets</span><span class="params">(<span class="type">char</span> *st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *ret_val;</span><br><span class="line">	<span class="type">char</span> *find;</span><br><span class="line"></span><br><span class="line">	ret_val = <span class="built_in">fgets</span>(st,n,stdin);</span><br><span class="line">	<span class="keyword">if</span>(ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//查找换行符</span></span><br><span class="line">		<span class="keyword">if</span>(find) <span class="comment">// 如果地址不是NULL</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">getchar</span>() !=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			 <span class="keyword">continue</span>; <span class="comment">// 处理输入行的剩余字符</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方式中makeinfo()函数返回的是一个结构。</p>
</blockquote>
<p>对于指针方式传递还是结构方式传递，两者输出结果相同，使用方式不同而已。</p>
<h4 id="结构和结构指针的选择">结构和结构指针的选择</h4>
<ul>
<li><strong>指针作为参数传递</strong>
<ul>
<li><strong>优点</strong>：无论是以前还是现在的C实现都能使用该方法，而且执行快，只需要<code>传递一个地址</code>。</li>
<li><strong>缺点</strong>：无法保护数据，故ANSI C新增<code>const限定符</code>可以解决这个问题。</li>
</ul>
</li>
<li><strong>结构作为参数传递</strong>
<ul>
<li><strong>优点</strong>：函数处理的是原始数据的副本，这可以保护原始数据。代码风格也很清楚。</li>
<li><strong>缺点</strong>：较老版本的实现可能无法处理，且传递结构浪费时间和存储空间。</li>
</ul>
</li>
</ul>
<p>👉<strong>小Tips</strong>：</p>
<ul>
<li>
<p>程序员为了追求效率会使用<code>结构指针</code>作为函数参数，如需<code>防止原始数据被意外修改</code>，使用 <code>const限定符</code>。</p>
</li>
<li>
<p>按<code>值传递结构</code>是处理小型结构最常用的方法。</p>
</li>
</ul>
<h4 id="结构中的字符数组和字符指针">结构中的字符数组和字符指针</h4>
<p>如果要用结构储存字符串，用字符数组作为成员比较简单。用指向char的指针也行，但是误用会导致严重的问题。（指针最好只用来在程序中管理那些已分配和在别处分配的字符串）</p>
<h4 id="结构、指针和malloc">结构、指针和<code>malloc()</code></h4>
<p>如果使用 <code>malloc()</code> 分配内存并使用指针存储该地址，那么在结构中使用指针处理字符串会比较合理。</p>
<p>优点：可以请求<code>malloc()</code>为字符串<code>分配合适的存储空间</code>。</p>
<p>⚠️注意：成对使用<code>malloc()</code>和<code>free()</code>(两个函数原型都在 <code>stdlib.h</code> 头文件中)。</p>
<h3 id="使用联合">使用联合</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>;   <span class="comment">// 把23存储在fit，占2字节</span></span><br><span class="line">fit.digfl = <span class="number">2.0</span>;  <span class="comment">// 清除23，存储2.0.占8字节</span></span><br><span class="line">fit.letter = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 清除2.0，存储h，占1个字节</span></span><br></pre></td></tr></table></figure>
<p><code>点运算符</code>：表示正在使用哪种数据类型。</p>
<p>用指针访问联合时要使用<code>-&gt;运算符</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu-&gt;digit;<span class="comment">//相当于 x = fit.digit</span></span><br></pre></td></tr></table></figure>
<p>在结构中储存与其成员有从属关系的信息（用一个成员把值储存在一个联合中，然后用另一个成员查看内容）。</p>
<p>匿名联合：一个机构或者联合的无名联合成员。</p>
<h3 id="枚举类型">枚举类型</h3>
<p>可以用<code>枚举类型(enumerated type)声明符号名称来表示整型变量</code>。使用<code>enum关键字</code>，可以创建一个新“类型”并指定它可具有的值（语法与结构的语法相同）。</p>
<p>目的:提高程序的可读性。</p>
<p>默认情况下，枚举常量是int类型的值，枚举列表中的常量都被赋予0，1，2等以此类推。</p>
<p>⚠️注意：C允许枚举变量使用 ++ 运算符，在C++标准中是不允许使用。</p>
<p>在枚举声明中，可以为枚举常量指定整数值。</p>
<blockquote>
<p>如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被后续赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">feline</span> &#123;cat, lynx = <span class="number">10</span>, puma, tiger&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="枚举enum的用法">枚举enum的用法</h4>
<p>目的：提高程序的可读性和可维护性。</p>
<p>⚠️注意：枚举只能在<code>内部使用</code>。</p>
<h3 id="typedef简介">typedef简介</h3>
<p>typedef是高级数据特性。利用typedef 可以为某一类型自定义名称。</p>
<p>typedef 的作用域取决于typedef定义所在的位置。</p>
<blockquote>
<p>如果定义在<code>函数内部</code>，属<code>局部作用域</code>。<br>
如果在<code>函数外部</code>，则具有<code>文件作用域</code>。</p>
</blockquote>
<h4 id="typedef-和-define-的区别"><code>typedef</code> 和 <code>#define</code> 的区别</h4>
<ul>
<li><code>typedef</code>创建的符号名只受限与类型，不能用于值。</li>
<li><code>typedef</code> 由<code>编译器</code>解释，而不是<code>预处理器</code>。</li>
<li>在其受限范围里，<code>typedef</code>比<code>#define</code>更灵活</li>
</ul>
<p>一般情况下，typeded定义中使用<code>大写字母</code>表示<code>被定义的名称</code>。也可以使用小写。</p>
<blockquote>
<p>typedef中使用的名称遵循变量命名的规则。</p>
</blockquote>
<p>将<code>typedef</code>用于来命名一个结构类型时，可以<code>省略结构的标签</code>。</p>
<h4 id="使用typedef的原因">使用typedef的原因</h4>
<ul>
<li>为经常出现的类型创建一个方便、易识别的类型名。</li>
<li>typedef常用来给复杂的类型命名。</li>
</ul>
<p>⚠️注意：使用<code>typedef</code>时，typedef并没有创建任何新类型，只是为某个已存在的类型增加方便使用的标签。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/06/21/c-primer-plus(1)/"><img class="prev-cover" src="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg" onerror="onerror=null;src='/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言基础（上）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/03/hash-table/" title="uthash头文件介绍"><img class="cover" src="https://pic2.zhimg.com/v2-4acb887a6240279c85ce9d43b7edd987_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-03</div><div class="title">uthash头文件介绍</div></div></a></div><div><a href="/2022/06/21/c-primer-plus(1)/" title="C语言基础（上）"><img class="cover" src="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-21</div><div class="title">C语言基础（上）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/litten.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李九居</div><div class="author-info__description">物性之苦者乐生焉</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="tencent://message?uin=2087628670"><i class="fab fa-qq"></i><span>联系我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liaozhangsheng" target="_blank" title="Github"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon" href="mailto:liaozhangsheng@163.com" target="_blank" title="邮箱"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon" href="tencent://message?uin=2087628670" target="_blank" title="QQ"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq"></use></svg></a><a class="social-icon" href="https://space.bilibili.com/475282948" target="_blank" title="B站"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>小道消息</span></div><div class="announcement_content">初次见面，多多关照</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">数组的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">声明数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">给数组元素赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%EF%BC%88C99%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">使用指定初始化器（C99）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">其他多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">1.3.</span> <span class="toc-text">数组和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.4.</span> <span class="toc-text">函数、数组和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">指针操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.</span> <span class="toc-text">保护数组中的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%EF%BC%88VLA%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">变长数组（VLA）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">字符串和字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2I-O"><span class="toc-number">2.1.</span> <span class="toc-text">表示字符串和字符串I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">字符串字面值（字符串常量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">字符串数组和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.</span> <span class="toc-text">数组和指针的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.</span> <span class="toc-text">字符串输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gets-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">gets() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fgets-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">fgets() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf-%E5%87%BD%E6%95%B0-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">scanf() 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.</span> <span class="toc-text">字符串输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#puts-%E5%87%BD%E6%95%B0%E5%92%8Cfputs-%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">puts()函数和fputs()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf-%E5%87%BD%E6%95%B0-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">printf()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84strcat-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">字符串拼接的strcat()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strncat-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">strncat()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83strcmp-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text">比较strcmp()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">strcpy() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strncpy-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.5.</span> <span class="toc-text">strncpy() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sprintf-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.6.</span> <span class="toc-text">sprintf() 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">2.5.</span> <span class="toc-text">字符串排序例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">命令行参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">文件输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.</span> <span class="toc-text">与文件进行通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O"><span class="toc-number">3.2.</span> <span class="toc-text">标准I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fopen-%E5%92%8C-fclose-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">fopen() 和 fclose() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getc-%E5%92%8C-putc-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">getc() 和 putc() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">一个简单的文件压缩程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.4.</span> <span class="toc-text">标准I&#x2F;O的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6I-O%EF%BC%9Afprintf-%E3%80%81fscanf-%E3%80%81fgets-%E3%80%81fputs"><span class="toc-number">3.3.</span> <span class="toc-text">文件I&#x2F;O：fprintf()、fscanf()、fgets()、fputs()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fprintf-%E5%92%8C-fscanf-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">fprintf() 和 fscanf() 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">3.4.</span> <span class="toc-text">随机访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fseek-%E5%92%8C-ftell-%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">fseek() 和 ftell() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fgetpos-%E5%92%8C-fsetpos-%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">fgetpos() 和 fsetpos() 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6I-O%EF%BC%9Afread-%E5%92%8C-fwrite"><span class="toc-number">3.5.</span> <span class="toc-text">二进制I&#x2F;O：fread() 和 fwrite()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96I-O%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">其他I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#size-t-fwrite-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">size_t fwrite() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#size-t-fread-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">size_t fread() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-feof-FILE-fp-%E5%92%8C-int-ferror-FILE-fp-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.3.</span> <span class="toc-text">int feof(FILE *fp) 和 int ferror(FILE *fp) 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6I-O%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">3.7.</span> <span class="toc-text">用二进制I&#x2F;O进行随机访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">结构和其他数据形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%9B%BE%E4%B9%A6%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.</span> <span class="toc-text">示例问题：创建图书目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">建立结构声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">定义结构变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.1.</span> <span class="toc-text">初始化结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-number">4.3.2.</span> <span class="toc-text">访问结构成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">结构的初始化器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.</span> <span class="toc-text">结构数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">声明结构数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">标识结构数组的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.3.</span> <span class="toc-text">嵌套结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.5.</span> <span class="toc-text">指向结构的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88"><span class="toc-number">4.5.1.</span> <span class="toc-text">声明和初始化结构指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98"><span class="toc-number">4.5.2.</span> <span class="toc-text">用指针访问成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">4.6.</span> <span class="toc-text">向函数传递结构的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-number">4.6.1.</span> <span class="toc-text">传递结构成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">4.6.2.</span> <span class="toc-text">传递结构的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.3.</span> <span class="toc-text">传递结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.6.4.</span> <span class="toc-text">其他结构特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.6.5.</span> <span class="toc-text">结构和结构指针的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-number">4.6.6.</span> <span class="toc-text">结构中的字符数组和字符指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cmalloc"><span class="toc-number">4.6.7.</span> <span class="toc-text">结构、指针和malloc()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88"><span class="toc-number">4.7.</span> <span class="toc-text">使用联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.</span> <span class="toc-text">枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEenum%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.8.1.</span> <span class="toc-text">枚举enum的用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef%E7%AE%80%E4%BB%8B"><span class="toc-number">4.9.</span> <span class="toc-text">typedef简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef-%E5%92%8C-define-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.1.</span> <span class="toc-text">typedef 和 #define 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8typedef%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.9.2.</span> <span class="toc-text">使用typedef的原因</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/markdown-grammar/" title="markdown基本语法"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.RE5i4GavSQYYG1pjjkseeAHaEt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.gif'" alt="markdown基本语法"/></a><div class="content"><a class="title" href="/2022/09/06/markdown-grammar/" title="markdown基本语法">markdown基本语法</a><time datetime="2022-09-06T13:47:40.000Z" title="发表于 2022-09-06 21:47:40">2022-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/05/markdown-math/" title="markdown数学公式"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.RE5i4GavSQYYG1pjjkseeAHaEt?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.gif'" alt="markdown数学公式"/></a><div class="content"><a class="title" href="/2022/09/05/markdown-math/" title="markdown数学公式">markdown数学公式</a><time datetime="2022-09-05T13:47:40.000Z" title="发表于 2022-09-05 21:47:40">2022-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/03/git-command/" title="Git命令"><img src="https://img1.baidu.com/it/u=1767290385,3158205709&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Git命令"/></a><div class="content"><a class="title" href="/2022/07/03/git-command/" title="Git命令">Git命令</a><time datetime="2022-07-02T23:55:32.000Z" title="发表于 2022-07-03 07:55:32">2022-07-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2022 By 李九居</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-reply"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-share"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-eye"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><div class="aplayer no-destroy" data-id="7499002642" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script src="/js/diy.js"></script><script src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script>new WOW().init();</script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/sakura.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script async data-pjax src="https://gcore.jsdelivr.net/gh/zhheo/JS-Heo@main/rightmenu/rightmenu.js"></script><script src="/js/iconfont.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:60px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.2.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.2.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(1)/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg" alt="" onerror="this.src=/img/default.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-06-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(1)/&quot;);" href="javascript:void(0);" alt="">C语言基础（上）</a><div class="blog-slider__text">C primer plus 中一些值得注意的点</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(1)/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(2)/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="http://img3m2.ddimg.cn/43/13/23958142-1_u_12.jpg" alt="" onerror="this.src=/img/default.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-06-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(2)/&quot;);" href="javascript:void(0);" alt="">C语言基础（下）</a><div class="blog-slider__text">C primer plus 中一些值得注意的点</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/06/21/c-primer-plus(2)/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/09/05/markdown-math/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://tse4-mm.cn.bing.net/th/id/OIP-C.RE5i4GavSQYYG1pjjkseeAHaEt?pid=ImgDet&amp;rs=1" alt="" onerror="this.src=/img/default.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/09/05/markdown-math/&quot;);" href="javascript:void(0);" alt="">markdown数学公式</a><div class="blog-slider__text">markdown数学公式参考</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/09/05/markdown-math/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/09/06/markdown-grammar/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://tse4-mm.cn.bing.net/th/id/OIP-C.RE5i4GavSQYYG1pjjkseeAHaEt?pid=ImgDet&amp;rs=1" alt="" onerror="this.src=/img/default.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/09/06/markdown-grammar/&quot;);" href="javascript:void(0);" alt="">markdown基本语法</a><div class="blog-slider__text">markdown基本语法参考</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/09/06/markdown-grammar/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>